// WIG (Warm Intro Graph) Database Schema
// Professional networking system for finding warm introduction paths

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// CORE ENTITIES
// ============================================================================

/// User represents an authenticated user of the system.
/// Owns data and has OAuth credentials for integrations.
model User {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Identity
  email String  @unique
  name  String?

  // Person association (migration from Person.metadata.isMe)
  personId String? @unique
  person   Person? @relation(fields: [personId], references: [id], onDelete: SetNull)

  // OAuth tokens for integrations (encrypted at rest)
  googleRefreshToken String? // Gmail OAuth refresh token
  googleAccessToken  String? // Gmail OAuth access token
  tokenExpiresAt     DateTime? // Token expiration timestamp

  // Sync timestamps
  lastGmailSyncAt DateTime? // Last time Gmail was synced

  // Ownership relationships
  ingestJobs         IngestJob[]
  evidenceEvents     EvidenceEvent[]
  conversations      Conversation[]
  messages           Message[]
  people             Person[]              @relation("UserPeople") // People created/imported by this user
  dataConnections    DataSourceConnection[] // User's connected data sources
  relationshipScores RelationshipScore[] // Relationship scores computed for this user

  // NextAuth.js relationships
  accounts Account[]
  sessions Session[]

  // Performance indexes
  @@index([email])
  @@map("users")
}

/// Account stores OAuth provider information (required by NextAuth.js)
model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

/// Session stores active user sessions (required by NextAuth.js)
model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

/// VerificationToken for email verification (required by NextAuth.js)
model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

/// DataSourceConnection represents a user's connection to an external data source.
/// Manages authentication, sync status, and privacy settings for each integration.
model DataSourceConnection {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Ownership
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Data source details
  sourceType       DataSourceType    // Type of data source (LinkedIn, Facebook, etc.)
  connectionStatus ConnectionStatus  // Current connection state

  // Authentication data (should be encrypted at rest)
  authData String? // Encrypted JSON with OAuth tokens/credentials

  // Source metadata
  // Structure: { profileUrl: "...", displayName: "...", connectionCount: 500, lastSyncStats: {...} }
  metadata Json?

  // Privacy settings
  privacyLevel PrivacyLevel @default(PRIVATE) // Data visibility level

  // Sync tracking
  lastSyncedAt DateTime? // Last successful sync from this source

  @@unique([userId, sourceType]) // One connection per source type per user
  // Performance indexes
  @@index([userId])
  @@index([userId, sourceType])
  @@index([connectionStatus])
  @@map("data_source_connections")
}

/// Person represents an individual in the network.
/// Supports entity resolution through arrays of names, emails, and phones.
/// Includes merge tracking and GDPR-compliant soft deletes.
model Person {
  id        String    @id @default(uuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // Soft delete for GDPR compliance

  // Identity fields - arrays support entity resolution
  names         String[] // Multiple name variations (nicknames, formal names)
  emails        String[] // All email addresses for this person
  phones        String[] // Phone numbers in various formats
  socialHandles Json? // { linkedin: "...", twitter: "...", github: "..." }

  // Professional information
  title          String?
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: SetNull)

  // Entity resolution & merge tracking
  mergeExplanation String? // Why this person was merged with others
  previousIds      String[] // IDs of persons merged into this one (for undo)

  // Source-specific metadata
  // Structure: { linkedin: { profileUrl: "...", connections: 500 }, gmail: { ... } }
  metadata Json?

  // Ownership (required - every person belongs to a user)
  userId String
  user   User   @relation("UserPeople", fields: [userId], references: [id], onDelete: Cascade)

  // User association (reverse relation from User model)
  owningUser User? @relation

  // Relationships
  outgoingEdges Edge[] @relation("FromPerson")
  incomingEdges Edge[] @relation("ToPerson")

  // Relationship scores (this person as source or target)
  outgoingScores RelationshipScore[] @relation("SourcePersonScores")
  incomingScores RelationshipScore[] @relation("TargetPersonScores")

  // Intro attempt relationships
  fromIntros       IntroAttempt[] @relation("FromPersonIntros")
  targetIntros     IntroAttempt[] @relation("TargetPersonIntros")
  introducerIntros IntroAttempt[] @relation("IntroducerIntros")

  // Task relationships
  tasks Task[]

  // Performance indexes
  @@index([userId]) // Multi-tenant queries
  @@index([userId, emails]) // Fast lookup by email within user context
  @@index([userId, phones]) // Fast lookup by phone within user context
  @@index([deletedAt]) // Filter out soft-deleted records
  @@index([emails]) // Fast lookup by email
  @@index([phones]) // Fast lookup by phone
  @@map("persons")
}

/// Organization represents a company or institution.
/// Linked to Person records for professional context.
model Organization {
  id        String    @id @default(uuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // Soft delete for GDPR compliance

  name   String
  domain String? // Company domain for email matching

  // Source-specific metadata
  // Structure: { linkedin: { companyId: "...", size: "..." }, clearbit: { ... } }
  metadata Json?

  // Relationships
  people Person[]

  @@index([domain])
  @@index([deletedAt])
  @@map("organizations")
}

/// Interaction represents communication events between people.
/// Captures emails, meetings, calls, messages, etc.
model Interaction {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Source information
  sourceId   String // ID from the source system (e.g., Gmail message ID)
  sourceName String // Source system name (e.g., "gmail", "outlook", "slack")

  // Interaction details
  timestamp    DateTime // When the interaction occurred
  participants String[] // Array of email addresses/identifiers
  channel      InteractionChannel // Communication channel type
  direction    InteractionDirection? // Communication direction if applicable

  // Additional context
  // Structure: { subject: "...", attendees: [...], duration: 30, ... }
  metadata Json?

  // Performance indexes
  @@index([timestamp]) // Chronological queries
  @@index([participants]) // Find interactions by participant
  @@index([sourceName, sourceId]) // Prevent duplicates from same source
  @@map("interactions")
}

// ============================================================================
// RELATIONSHIP SCORING
// ============================================================================

/// RelationshipScore captures computed relationship strength between two people.
/// Used by the pathfinding algorithm to find warm intro paths.
/// All scores are normalized to 0.0-1.0 range.
model RelationshipScore {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Ownership (required - every score belongs to a user)
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Relationship endpoints
  sourcePersonId String
  targetPersonId String
  sourcePerson   Person @relation("SourcePersonScores", fields: [sourcePersonId], references: [id], onDelete: Cascade)
  targetPerson   Person @relation("TargetPersonScores", fields: [targetPersonId], references: [id], onDelete: Cascade)

  // Individual scoring factors (0.0-1.0)
  recencyScore       Float @default(0.0) // Higher = more recent interaction
  frequencyScore     Float @default(0.0) // Higher = more frequent interaction
  bidirectionalScore Float @default(0.0) // Higher = more balanced communication
  channelDiversity   Float @default(0.0) // Higher = more channels used

  // Composite scores (0.0-1.0)
  overallScore Float @default(0.0) // Weighted combination of all factors
  confidence   Float @default(0.0) // Confidence in the score (based on data completeness)

  // Interaction metadata
  interactionCount  Int       @default(0) // Total interactions counted
  lastInteractionAt DateTime? // Most recent interaction timestamp

  // Unique constraint: one score per user+source+target combination
  @@unique([userId, sourcePersonId, targetPersonId])

  // Performance indexes
  @@index([userId])
  @@index([userId, overallScore])
  @@index([sourcePersonId])
  @@index([targetPersonId])
  @@map("relationship_scores")
}

// ============================================================================
// GRAPH RELATIONSHIPS
// ============================================================================

/// Edge represents a relationship between two people in the network graph.
/// Includes relationship strength, sources, and interaction metadata.
model Edge {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationship endpoints
  fromPersonId String
  toPersonId   String
  fromPerson   Person @relation("FromPerson", fields: [fromPersonId], references: [id], onDelete: Cascade)
  toPerson     Person @relation("ToPerson", fields: [toPersonId], references: [id], onDelete: Cascade)

  // Relationship metadata
  relationshipType RelationshipType // Type of relationship
  strength         Float            @default(0.0) // Computed score 0.0-1.0

  // Explainability: Why this strength score?
  // Structure: { recency: 0.8, frequency: 0.6, mutuality: 0.9, ... }
  strengthFactors Json?

  // Top evidence IDs that justify this edge strength (for UI explainability)
  // References to EvidenceEvent IDs - top 3-5 most important pieces of evidence
  topEvidenceIds String[] @default([])

  // Provenance
  sources  String[] // Data sources: ["linkedin", "gmail", "calendar"]
  channels String[] // Interaction channels: ["email", "meeting"]

  // Temporal tracking
  firstSeenAt      DateTime // When relationship first observed
  lastSeenAt       DateTime // Most recent interaction
  interactionCount Int      @default(0) // Total number of interactions

  @@unique([fromPersonId, toPersonId]) // One edge per direction per pair
  // Performance indexes
  @@index([fromPersonId]) // Graph traversal from source
  @@index([toPersonId]) // Graph traversal to target
  @@index([lastSeenAt]) // Find recent relationships
  @@index([strength]) // Find strongest connections
  @@map("edges")
}

// ============================================================================
// SYSTEM STATE
// ============================================================================

/// SyncState tracks synchronization status for each data source.
/// Enables incremental syncing and error recovery.
model SyncState {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sourceName String  @unique // Data source identifier
  cursor     String? // Pagination/sync cursor for incremental updates

  // Status tracking
  lastSyncAt    DateTime? // Last sync attempt
  lastSuccessAt DateTime? // Last successful sync
  lastError     String? // Error message from last failed sync
  status        SyncStatus @default(idle)

  // Source-specific metadata
  // Structure: { totalRecords: 1234, newRecords: 56, errors: [...] }
  metadata Json?

  @@map("sync_states")
}

/// AuditLog tracks all significant system actions for compliance and debugging.
/// Includes correlation IDs for tracing multi-step operations.
model AuditLog {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  // Operation tracking
  correlationId String // Group related operations (e.g., merge cascade)
  action        String // Action type: "person.merged", "data.synced", etc.

  // Actor information
  actorId String? // User/system ID that triggered action (null for system)

  // Entity reference
  entityType String // Type of entity affected: "Person", "Edge", etc.
  entityId   String // ID of the affected entity

  // Event-specific metadata
  // Structure: { before: {...}, after: {...}, reason: "...", ... }
  metadata Json?

  // Performance indexes
  @@index([createdAt]) // Chronological queries
  @@index([correlationId]) // Trace related operations
  @@index([entityType, entityId]) // Find all actions on an entity
  @@map("audit_logs")
}

// ============================================================================
// INTRO WORKFLOW
// ============================================================================

/// IntroAttempt tracks warm introduction requests through their lifecycle.
/// Links requester, target, and introducer with path snapshot and status.
model IntroAttempt {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // The outreach request participants
  fromPersonId   String // Person asking to be introduced
  targetPersonId String // Person we want to meet
  introducerId   String // Person who can make the intro

  fromPerson   Person @relation("FromPersonIntros", fields: [fromPersonId], references: [id], onDelete: Cascade)
  targetPerson Person @relation("TargetPersonIntros", fields: [targetPersonId], references: [id], onDelete: Cascade)
  introducer   Person @relation("IntroducerIntros", fields: [introducerId], references: [id], onDelete: Cascade)

  // Path and context
  pathSnapshot Json // Snapshot of the path at request time

  // Message details
  message String
  channel String

  // Status tracking
  status IntroStatus @default(draft)

  // Lifecycle timestamps
  sentAt      DateTime?
  respondedAt DateTime?
  completedAt DateTime?

  // Outcome
  outcome IntroOutcome?

  // Performance indexes
  @@index([fromPersonId])
  @@index([targetPersonId])
  @@index([status])
  @@index([createdAt])
  @@map("intro_attempts")
}

/// Draft represents AI-generated message templates for outreach.
/// Stores generated content with metadata about generation process.
model Draft {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  // Context
  introAttemptId String?
  targetPersonId String
  introducerId   String?

  // Channel and content
  channel String
  subject String?
  body    String
  tone    String?

  // Generation metadata
  generatedBy String
  model       String?

  // Status
  status     DraftStatus @default(generated)
  selectedAt DateTime?

  // Performance indexes
  @@index([targetPersonId])
  @@index([status])
  @@map("drafts")
}

/// Task represents follow-ups, reminders, and workflow automation.
/// Links to people and intro attempts for context.
model Task {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  // Task details
  title       String
  description String?
  type        TaskType
  status      TaskStatus   @default(pending)
  priority    TaskPriority @default(medium)

  // Relationships
  relatedPersonId String?
  introAttemptId  String?

  relatedPerson Person? @relation(fields: [relatedPersonId], references: [id], onDelete: SetNull)

  // Timing
  dueAt       DateTime?
  completedAt DateTime?

  // Performance indexes
  @@index([status, dueAt])
  @@index([relatedPersonId])
  @@map("tasks")
}

// ============================================================================
// ENUMS
// ============================================================================

enum InteractionChannel {
  email
  message
  meeting
  call
  other
}

enum InteractionDirection {
  one_way // Asymmetric (e.g., broadcast email)
  two_way // Symmetric (e.g., conversation)
}

enum RelationshipType {
  knows // General acquaintance
  connected_to // Explicitly connected (LinkedIn, etc.)
  interacted_with // Based on communication history
  worked_at // Professional relationship
  advised // Mentor/advisor relationship
  invested_in // Investor relationship
}

enum SyncStatus {
  idle // Not currently syncing
  running // Sync in progress
  failed // Last sync failed
  success // Last sync succeeded
}

enum IntroStatus {
  draft // Just created, not sent
  sent // Message delivered
  responded // Introducer responded
  completed // Intro successfully made
  declined // Introducer declined
}

enum IntroOutcome {
  meeting_scheduled // Meeting scheduled with target
  intro_made // Introduction made successfully
  declined // Introducer declined
  no_response // No response from introducer
}

enum DraftStatus {
  generated // AI generated, not reviewed
  selected // User selected this draft
  sent // Draft was sent
  discarded // User rejected this draft
}

enum TaskType {
  follow_up // Follow up on intro attempt
  reminder // Reminder to do something
  outreach // Outreach to person
}

enum TaskStatus {
  pending // Not yet started
  completed // Task completed
  cancelled // Task cancelled
}

enum TaskPriority {
  low
  medium
  high
}

enum DataSourceType {
  LINKEDIN
  FACEBOOK
  EMAIL
  TWITTER
  GITHUB
  CALENDAR
}

enum ConnectionStatus {
  CONNECTED
  DISCONNECTED
  ERROR
  PENDING
}

enum PrivacyLevel {
  PRIVATE           // Only visible to owner
  CONNECTIONS_ONLY  // Visible to direct connections (future feature)
  PUBLIC            // Visible to all users (future feature)
}

// ============================================================================
// EVIDENCE & LINKEDIN INTEGRATION
// ============================================================================

/// EvidenceEvent captures interaction evidence for relationship scoring and explainability.
/// Each event represents a piece of proof that strengthens or explains a relationship.
model EvidenceEvent {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Ownership (required - every evidence belongs to a user)
  userId String // User who owns this evidence
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Relationship this evidence supports
  subjectPersonId String // Primary person this evidence is about
  objectPersonId  String? // Optional counterparty (for interactions)

  // Evidence details
  type      EvidenceType
  timestamp DateTime // When the evidence occurred
  source    String // Source system: "linkedin_archive", "linkedin_api", "gmail", etc.

  // Auditability - reference to raw data
  // Structure: { bucket: "s3-bucket", key: "path/to/file", recordId: "row-123" }
  rawRef Json?

  // Event-specific metadata
  // Structure varies by type:
  //   linkedin_connection: { connectedAt: "...", mutualConnections: 50 }
  //   linkedin_message_sent: { threadId: "...", messageLength: 250, conversationId: "..." }
  //   email_thread: { subject: "...", threadLength: 5 }
  metadata Json?

  // Performance indexes
  @@index([userId, timestamp])
  @@index([subjectPersonId, timestamp])
  @@index([objectPersonId, timestamp])
  @@index([type, timestamp])
  @@index([source])
  @@map("evidence_events")
}

/// Conversation represents a message thread (LinkedIn DM, email thread, etc.)
model Conversation {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Ownership (inbox owner - required)
  userId String // User who owns this conversation
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Source tracking
  externalId String // ID from source system (LinkedIn thread ID, Gmail thread ID)
  sourceName String // Source system: "linkedin", "gmail", "slack"

  // Participants (array of person IDs)
  participants String[]

  // Conversation metadata
  // Structure: { subject: "...", messageCount: 12, lastActivity: "..." }
  metadata Json?

  // Relationships
  messages Message[]

  @@unique([sourceName, externalId])
  // Performance indexes
  @@index([userId])
  @@index([sourceName, externalId])
  @@index([participants])
  @@map("conversations")
}

/// Message represents individual messages within conversations
model Message {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  // Ownership (inbox owner - required)
  userId String // User who owns this message
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Message location
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // Message details
  senderId  String // Person ID of sender
  timestamp DateTime // When message was sent

  // Content (optionally encrypted)
  content String? // Message body (can be encrypted at rest)

  // Message metadata
  // Structure: { length: 250, attachments: [...], hasSchedulingLanguage: true }
  metadata Json?

  // Performance indexes
  @@index([userId])
  @@index([conversationId, timestamp])
  @@index([senderId, timestamp])
  @@map("messages")
}

/// IngestJob tracks long-running data import operations
model IngestJob {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Job details (required - every job belongs to a user)
  userId     String // User who initiated the job
  user       User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  sourceName String // Data source: "linkedin_archive", "gmail", etc.
  status     IngestJobStatus @default(queued)

  // File tracking
  // Structure: { fileName: "archive.zip", fileSize: 12345, storageKey: "s3://..." }
  fileMetadata Json?

  // Progress tracking
  progress Int @default(0) // Percentage 0-100

  // Timing
  startedAt   DateTime?
  completedAt DateTime?

  // Error handling
  error String? // Error message if failed

  // Results and statistics
  // Structure: { connectionsProcessed: 500, messagesProcessed: 1200, errorsCount: 3, newPersons: 50 }
  resultMetadata Json?

  // Job logs (chunked for large outputs)
  logs String?

  // Performance indexes
  @@index([userId, createdAt])
  @@index([status])
  @@index([sourceName])
  @@map("ingest_jobs")
}

// ============================================================================
// ADDITIONAL ENUMS
// ============================================================================

enum EvidenceType {
  linkedin_connection
  linkedin_message_sent
  linkedin_message_received
  linkedin_post_authored
  linkedin_invitation_sent
  linkedin_invitation_received
  linkedin_comment_authored
  linkedin_reaction
  email_sent
  email_received
  calendar_meeting
  phone_call
  human_confirmed_connection
  manual_note
}

enum IngestJobStatus {
  queued
  running
  completed
  failed
  cancelled
}

// ============================================================================
// CHANGELOG & REQUIREMENT TRACKING
// ============================================================================

/// ChangelogEntry tracks all development work including requirements, tasks, and bugs
/// Replaces static REQUIREMENTS array with dynamic, real-time tracking
model ChangelogEntry {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Entry identification
  entryId     String @unique // REQ-001, TASK-001, BUG-001
  requirement String // Title/description of the work

  // Classification
  priority ChangelogPriority // Critical, High, Medium, Low
  status   ChangelogStatus   @default(planned) // Planned, In Progress, In Review, Done, Blocked, On Hold
  category String // Feature, Enhancement, Bug Fix, Infrastructure, Quality

  // Details
  notes String? // Additional context and technical details

  // Lifecycle timestamps
  dateAdded     DateTime
  dateStarted   DateTime?
  dateCompleted DateTime?

  // Version tracking
  version String? // Version where this was completed (e.g., "0.8.1")

  // GitHub integration
  githubIssueNumber Int? // GitHub issue number (e.g., 5 for issue #5)
  githubIssueUrl    String? // Full GitHub issue URL

  // Source tracking
  sourceType    ChangelogSource @default(user_request) // Where this requirement originated
  sourceDetails String? // Additional source context (e.g., "Requested by CEO in standup")

  // Performance indexes
  @@index([status])
  @@index([priority])
  @@index([dateAdded])
  @@index([githubIssueNumber])
  @@index([sourceType])
  @@map("changelog_entries")
}

enum ChangelogPriority {
  critical
  high
  medium
  low
}

enum ChangelogStatus {
  planned
  in_progress
  in_review
  done
  blocked
  on_hold
}

enum ChangelogSource {
  github_issue    // Created from GitHub issue
  user_request    // Direct user request in conversation
  internal        // Internal initiative (Steve/team)
  customer        // External customer feedback
  system          // System-generated (e.g., dependency updates)
}
